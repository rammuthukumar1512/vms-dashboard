import { Component, OnInit, OnDestroy, Inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatTableModule } from '@angular/material/table';
import { MatDialogModule, MatDialog, MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';
import { MatIconModule } from '@angular/material/icon';
import { FormsModule } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { Subject, takeUntil } from 'rxjs';
import { environments } from '../../environments/environments';
import { ToastService } from '../core/services/toast.service';
import { CveResult, CpeResult, CvssMetric } from '../models/computer.model'; // Add this import
import { CpeVulnerabilityDialogComponent } from './cpe-vulnerability-dialog.component';

@Component({
  selector: 'app-cpe-cve-search',
  standalone: true,
  imports: [
    CommonModule,
    MatFormFieldModule,
    MatSelectModule,
    MatInputModule,
    MatButtonModule,
    MatTableModule,
    MatDialogModule,
    MatIconModule,
    FormsModule,
  ],
  templateUrl: './cpe-cve-search.component.html',
  styleUrls: ['./cpe-cve-search.component.css']
})
export class CpeCveSearchComponent implements OnInit, OnDestroy {
  searchType: 'cve' | 'cpe' = 'cve';
  searchVariant: string = 'Select Variant';
  searchQuery: string = '';
  placeholder: string = 'Enter search query';
  cveResults: CveResult[] = [];
  cpeResults: CpeResult[] = [];
  searchPerformed: boolean = false; // New flag to control table visibility
  pagedCveResults: CveResult[] = [];
  pagedCpeResults: CpeResult[] = [];
  cveDisplayedColumns: string[] = ['cveId', 'description', 'cvssVersion', 'severity', 'cvssScore'];
  cpeDisplayedColumns: string[] = ['cpeName'];
  pageIndex = 0;
  pageSize = 5;
  pageSizes: number[] = [5, 10, 25, 50, 100];
  cveTotalPages = 0;
  cpeTotalPages = 0;
  cveTotalRecords: number[] = [];
  cpeTotalRecords: number[] = [];
  start = 0;
  end = 0;
  recordIndex = 1;
  sortState: number = 0; // 0 = no sort, 1 = ascending, 2 = descending
  private cpePattern = /^cpe:2\.3:[aho](:[^:]*){0,10}$/;
  // private strictCpePattern = /^cpe:2\.3:[aho](:[^:]*){10}$/;
  private strictCpePattern = /^cpe:2\.3:[aho]:[a-zA-Z0-9][^:]*:[a-zA-Z0-9][^:]*:[^:]+(?::[^:]*){7}$/;
  private cveIdPattern = /^CVE-\d{4}-\d{4,}$/;
  private destroy$ = new Subject<void>();

  constructor(
    private http: HttpClient,
    private dialog: MatDialog,
    private toastService: ToastService,
  ) {}

  ngOnInit(): void {}

  getSearchVariants(): string[] {
    return this.searchType === 'cve'
      ? ['Select Variant', 'Keyword', 'CVE-ID', 'CPE Name']
      : ['Select Variant', 'Keyword', 'Likely CPE Name'];
  }

  onSearchTypeChange(): void {
    this.searchVariant = 'Select Variant';
    this.updatePlaceholderAndQuery();
    this.clearResults();
    // this.toastService.showToast(`Search type set to ${this.searchType.toUpperCase()}`);

  }

  onSearchVariantChange(): void {
    this.updatePlaceholderAndQuery();
    this.clearResults();
    // this.toastService.showToast(`Search variant set to ${this.searchVariant}`);

  }

  updatePlaceholderAndQuery(): void {
    this.searchQuery = '';
    if (this.searchVariant === 'CVE-ID') {
      this.searchQuery = 'CVE-';
      this.placeholder = 'Enter CVE-ID (e.g., CVE-1234-1234)';
    } else if (this.searchVariant === 'CPE Name') {
       this.searchQuery = 'cpe:2.3:*:*:*:*:*:*:*:*:*:*:*'
      this.placeholder = 'Enter the valid CPE name (e.g., cpe:2.3:a:microsoft:edge:138.0.3351.77:*:*:*:*:*:*:*)';
    } else if (this.searchVariant === 'Keyword') {
      this.placeholder = 'Enter the keyword';
    } else { 
      this.placeholder = 'Enter search query';
    }
  }

  clearResults(): void {
    this.cveResults = [];
    this.cpeResults = [];
    this.pagedCveResults = [];
    this.pagedCpeResults = [];
    this.pageIndex = 0;
    this.recordIndex = 1;
    this.cveTotalPages = 0;
    this.cpeTotalPages = 0;
    this.cveTotalRecords = [];
    this.cpeTotalRecords = [];
    this.searchPerformed = false; // Reset searchPerformed when clearing results
    // this.toastService.showToast('Search results cleared');

  }

  validateInput(): boolean {
    if ( this.searchVariant === 'Select Variant') {
    this.toastService.showToast('Select a valid search variant');
      return false;
    }
    if(!this.searchQuery.trim()){
      this.toastService.showToast('Search term cannot be Empty.Enter a valid search term.');

    }

    if (this.searchVariant === 'CPE Name' && !this.strictCpePattern.test(this.searchQuery)) {
      this.toastService.showToast('Invalid CPE format. Must be a full CPE name (e.g., cpe:2.3:a:microsoft:edge:138.0.3351.77:*:*:*:*:*:*:* )')
      return false;
    }

    if (this.searchVariant === 'Likely CPE Name' && !this.cpePattern.test(this.searchQuery)) {
      this.toastService.showToast('Invalid CPE format. Must start with cpe:2.3:[a|o|h]')
      return false;
    }

    if (this.searchVariant === 'CVE-ID' && !this.cveIdPattern.test(this.searchQuery)) {
      this.toastService.showToast('Invalid CVE-ID format. Must be CVE-YYYY-YYYY');
      return false;
    }
  const query = this.searchQuery?.trim();

if (!query) {
  this.toastService.showToast('Field cannot be empty.');
  return false;
}


    if (this.searchType === 'cpe' && this.searchVariant === 'Keyword' || this.searchType === 'cve' && this.searchVariant === 'Keyword' ) {
      const words = this.searchQuery.trim();
      console.log("keyword length : ", words.length);
      if (words.length < 3) {
     this.toastService.showToast("Keyword search requires at least 3 letters")
        return false;
      }
    }

    return true;
  }


  search(): void {
  // this.toastService.showToast('Searching for results...');
this.pageIndex = 0, this.recordIndex = 1, this.pageSize = 5
  if (!this.validateInput()) {
    return;
  }

  const params: any = {};
  console.log("search variant: ", this.searchVariant);
  console.log(this.searchVariant === 'CPE Name');
  console.log('>' + this.searchVariant + '<', this.searchVariant.length);
  if (this.searchVariant === 'Keyword') {
    params.searchKeyword = this.searchQuery;
  } else if (this.searchVariant === 'CVE-ID') {
    params.searchCveId = this.searchQuery;
  } else if (this.searchVariant === 'CPE Name' || this.searchVariant === 'Likely CPE Name') {
    console.log(this.searchQuery)
    params.searchCpeName = this.searchQuery;
    console.log(params.searchCpeName)
  }

  this.http.get<any>(
    `${environments.searchVulnerabilityUrl}/${this.searchType}`,
    { params }
  ).subscribe({
    next: (data) => {
      console.log("cve search result: ", data)
      if (this.searchType === 'cve') {
        this.cveResults = (data || []).map((item: any) => ({
          cveId: item.cveId,
          cveDescription: item.cveDescription,
          cvssMetrics: item.cvssMetrics
            ? item.cvssMetrics.sort((a: CvssMetric, b: CvssMetric) => parseFloat(b.version) - parseFloat(a.version))
            : [],
          affectedProducts: item.affectedProducts || []
        }));
        this.updateCvePagedData(0);
        this.searchPerformed = true; // Set flag to true after successful search
        // this.toastService.showToast("Successfully fetched CVE search result");
        this.toastService.showToast("Search Completed Successfully");
      } else {
        console.log("CPE search results : ", data)
        this.cpeResults = (data || []).map((item: any) => ({
          cpe23Uri: item.cpe23Uri,
          vendor: item.vendor,
          product: item.product,
          version: item.version
        }));
        this.updateCpePagedData(0);
        this.searchPerformed = true; // Set flag to true after successful search
        // this.toastService.showToast("Successfully fetched CPE search result");
        this.toastService.showToast("Search Completed Successfully");
      }
    },
    error: (error) => {
      console.error(`Error searching ${this.searchType.toUpperCase()}:`, error);
      this.toastService.showToast(`Failed to search ${this.searchType.toUpperCase()} data.`);
      // Clear results on error
      if (this.searchType === 'cve') {
        this.cveResults = [];
        this.pagedCveResults = [];
        this.cveTotalPages = 0;
        this.cveTotalRecords = [];
      } else {
        this.cpeResults = [];
        this.pagedCpeResults = [];
        this.cpeTotalPages = 0;
        this.cpeTotalRecords = [];
      }
      this.searchPerformed = false; // Reset flag on error
    }
  });
}

  openCpeVulnerabilities(cpe: CpeResult): void {
    this.http.get<CveResult[]>(
      `${environments.searchVulnerabilityUrl}/cve`,
      { params: { searchCpeName: cpe.cpe23Uri } }
    ).subscribe({
      next: (data) => {
        this.toastService.showToast('Loading vulnerabilities for selected CPE...');
        const vulnerabilities = (data || []).map((item: any) => ({
          cveId: item.cveId,
          cveDescription: item.cveDescription,
          cvssMetrics: item.cvssMetrics
            ? item.cvssMetrics.sort((a: CvssMetric, b: CvssMetric) => parseFloat(b.version) - parseFloat(a.version))
            : [],
          affectedProducts: item.affectedProducts || []
        }));
        this.dialog.open(CpeVulnerabilityDialogComponent, {
          width: '1000px',
          data: {
            cpeName: cpe.cpe23Uri,
            vulnerabilities
          }
        });
      },
      error: (error) => {
        console.error('Error fetching vulnerabilities for CPE:', error);
        this.toastService.showToast('Unable to retrieve CPE vulnerability data.')
      }
    });
  }

//   updateCvePagedData(initialIndex: number): void {
//     if (!this.pageSizes.includes(this.pageSize)) {
//   this.pageSize = this.pageSizes[0];  // fallback to smallest valid option
// }

//   const totalItems = this.cveResults.length;

//   // Dynamically set page size options
//   this.pageSizes = totalItems >= 100 ? [5, 10, 25, 50, 100] :
//                     totalItems >= 50  ? [5, 10, 25, 50] :
//                     totalItems >= 25  ? [5, 10, 25] :
//                     totalItems >= 10  ? [5, 10] :
//                     totalItems > 0    ? [5] : [0];

//   this.cveTotalPages = Math.ceil(totalItems / this.pageSize);
//   this.cveTotalRecords = Array.from({ length: this.cveTotalPages }, (_, i) => i + 1);
//   this.start = initialIndex * this.pageSize;
//   this.end = this.start + this.pageSize;
//   this.pagedCveResults = this.cveResults.slice(this.start, this.end);
// }


updateCvePagedData(initialIndex: number): void {
    if (!this.pageSizes.includes(this.pageSize)) {
      this.pageSize = this.pageSizes[0] || 5; // Fallback to 5 if pageSizes is empty
    }

    const totalItems = this.cveResults.length;

    // Dynamically set page size options
    this.pageSizes = totalItems >= 100 ? [5, 10, 25, 50, 100] :
                    totalItems >= 50  ? [5, 10, 25, 50] :
                    totalItems >= 25  ? [5, 10, 25] :
                    totalItems >= 10  ? [5, 10] :
                    totalItems > 0    ? [5] : [];

    // Apply sorting based on sortState
    let sortedResults = [...this.cveResults];
    if (this.sortState === 1) {
      sortedResults.sort((a, b) => (a.cvssMetrics[0]?.baseScore ?? 0) - (b.cvssMetrics[0]?.baseScore ?? 0));
    } else if (this.sortState === 2) {
      sortedResults.sort((a, b) => (b.cvssMetrics[0]?.baseScore ?? 0) - (a.cvssMetrics[0]?.baseScore ?? 0));
    }
    this.cveTotalPages = Math.ceil(totalItems / this.pageSize);
    this.cveTotalRecords = Array.from({ length: this.cveTotalPages }, (_, i) => i + 1);
    this.start = initialIndex * this.pageSize;
    this.end = this.start + this.pageSize;
    this.pagedCveResults = sortedResults.slice(this.start, this.end);
  }

  updateCpePagedData(initialIndex: number): void {
    if (!this.pageSizes.includes(this.pageSize)) {
  this.pageSize = this.pageSizes[0] || 5;  // fallback to smallest valid option
}

  const totalItems = this.cpeResults.length;

  // Dynamically set page size options
  this.pageSizes = totalItems >= 100 ? [5, 10, 25, 50, 100] :
                    totalItems >= 50  ? [5, 10, 25, 50] :
                    totalItems >= 25  ? [5, 10, 25] :
                    totalItems >= 10  ? [5, 10] :
                    totalItems > 0    ? [5] : [];

  this.cpeTotalPages = Math.ceil(totalItems / this.pageSize);
  this.cpeTotalRecords = Array.from({ length: this.cpeTotalPages }, (_, i) => i + 1);
  this.start = initialIndex * this.pageSize;
  this.end = this.start + this.pageSize;
  this.pagedCpeResults = this.cpeResults.slice(this.start, this.end);
}



toggleCvssSort(): void {
    if (this.searchType !== 'cve') return; // Only apply sorting to CVE results
    this.sortState = (this.sortState + 1) % 3; // Cycle through 0 (no sort), 1 (ascending), 2 (descending)
    this.updateCvePagedData(this.pageIndex); // Reapply pagination with new sort
  }

  nextPage(tab: 'cve' | 'cpe'): void {
    if (tab === 'cve' && this.pageIndex < this.cveTotalPages - 1) {
      this.pageIndex++;
      this.recordIndex = this.pageIndex + 1;
      this.updateCvePagedData(this.pageIndex);
    } else if (tab === 'cpe' && this.pageIndex < this.cpeTotalPages - 1) {
      this.pageIndex++;
      this.recordIndex = this.pageIndex + 1;
      this.updateCpePagedData(this.pageIndex);
    }
  }

  previousPage(tab: 'cve' | 'cpe'): void {
    if (this.pageIndex > 0) {
      this.pageIndex--;
      this.recordIndex = this.pageIndex + 1;
      tab === 'cve' ? this.updateCvePagedData(this.pageIndex) : this.updateCpePagedData(this.pageIndex);
    }
  }

  getPage(page: number, tab: 'cve' | 'cpe'): void {
    this.pageIndex = page - 1;
    this.recordIndex = page;
    tab === 'cve' ? this.updateCvePagedData(this.pageIndex) : this.updateCpePagedData(this.pageIndex);
  }

  onPageSizeChange(event: number, tab: 'cve' | 'cpe'): void {
    this.pageSize = event;
    this.pageIndex = 0;
    this.recordIndex = 1;
    tab === 'cve' ? this.updateCvePagedData(this.pageIndex) : this.updateCpePagedData(this.pageIndex);
      // this.toastService.showToast(`Page size set to ${event}.`);

  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}