import { HttpClient, HttpErrorResponse, HttpHeaders, HttpParams, HttpResponse } from '@angular/common/http';
import { ChangeDetectorRef, Component, ElementRef, OnInit, Renderer2, ViewChild } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { CommonModule, Location } from '@angular/common';
import { ApiEndPoints } from '../../../environments/api-endpoints';
import { Subject, takeUntil } from 'rxjs';
import { Chart } from 'chart.js';
import { MatIconModule } from '@angular/material/icon';
import { ToastService } from '../../core/services/toast.service';



@Component({
  selector: 'app-vulnerability-metrics',
  standalone: true,
  imports: [CommonModule ,MatIconModule],
  templateUrl: './vulnerability-metrics.component.html',
  styleUrls: ['./vulnerability-metrics.component.css']
})
export class VulnerabilityMetricsComponent implements OnInit {
  @ViewChild('affectedProductsTemplate') affectedProductsTemplateRef!: ElementRef;
  @ViewChild('affectedProductsChild') affectedProductsChildRef!: ElementRef;
  @ViewChild('remediationTemplate') remediationTemplate!: ElementRef;
  @ViewChild('remediationChild') remediationChild!: ElementRef;
  @ViewChild('baseScoreParent') baseScoreParent!: ElementRef;
  @ViewChild('baseScoreChild') baseScoreChild!: ElementRef;
  @ViewChild('baseScoreFooter') baseScoreFooter!: ElementRef;
  @ViewChild('noVulnerability') noVulnerability!: ElementRef;
  @ViewChild('severityChart', { static: false }) severityChart!: ElementRef<HTMLCanvasElement>;
  vulnerabilityData:any = {};
  metricData:any = {};
  affectedProducts:Array<any> = [];
  references:Array<any> = [];
  baseScore:number = 0;
  cveId:string = "";
  attackVector:string = "";
  attackComplexity:string = "";
  privilegesRequired:string = "";
  userInteraction:string = "";
  scope:string = "";
  confidentiality:string = "";
  integrity:string = "";
  availability:string = "";
  version:string = "";
  vectorString:string = "";
  cvssMetrics:Array<any> = [];
  textColor:string = "#000000";
  hasVulnerability:boolean = true;
  cdRef: ChangeDetectorRef | undefined;
  currentVersionData: any = {};
  btnActiveIndex: number = 0;
  private destroy$ = new Subject<void>();

  severityChartInstance!: Chart;

  constructor(private http: HttpClient, private route: ActivatedRoute, private renderer: Renderer2,
   private location: Location, private toastService: ToastService
  ) {}
    
  ngOnInit(): void {
    this.route.params.subscribe(params =>{
      const type = params['type'];
      const cveId = params['cveId'];
      console.log(type, cveId)
      this.fetchVulnerabilityMetrics( type, cveId);
    })
  }

   ngAfterViewInit(): void {
    this.afterDataUpdate();
  }
  public drawSeverityBasedComputerChart() {

     if (!this.severityChart?.nativeElement) return;
      const ctx = this.severityChart.nativeElement.getContext('2d');
      if (!ctx) return;
      if (this.severityChartInstance) {
        this.severityChartInstance.destroy();
      }
  const baseScore = this.currentVersionData?.baseScore;
  const impactScore = this.currentVersionData?.impactScore;
  const exploitabilityScore = this.currentVersionData?.exploitabilityScore;    

  this.severityChartInstance = new Chart(ctx, {
    
    type: 'bar',
    data: {
       labels: ['Base', 'Impact', 'Exploitability'],
    datasets: [
      {
        data: [baseScore, impactScore, exploitabilityScore],
        label: 'Scores',
        backgroundColor: [ '#33658A', '#86BBD8', '#5475bbff' ], 
        borderRadius: 4
      }
    ]
    },
    options: {
       responsive: true,
    scales: {
      x: {
        title: {
          display: true,
          text: 'Score Type',
          color: this.textColor
        },
        ticks: {
          color: this.textColor
        },
        grid: {
          color: '#ccc'
        }
      },
      y: {
        min: 0.0,
        max: 10.0,
        ticks: {
          stepSize: 2,
          color: this.textColor
        },
        title: {
          display: true,
          text: 'Score Value (0.0-10.0)',
          color: this.textColor
        },
        grid: {
          color: '#ccc'
        }
      }
    },
    plugins: {
      legend: { display: false },
      tooltip: {
        callbacks: {
          label: function (context) {
            return `${context.label}: ${context.parsed.y}`;
          }
        }
      },
      datalabels:{
        color: 'gray',
        anchor: 'end',
        align: 'end'
      }
    }
    }
  });
  }
 
private fetchVulnerabilityMetrics(type:String, cveId: String) {
 const headers = new HttpHeaders({
    'Accept': 'application/json'
    });
    const params = new HttpParams().set('searchCveId', cveId.toString());
    this.http.get<any>(`${ApiEndPoints.searchVulnerabilityUrl}/${type}`, { params, headers })
      .pipe(
        takeUntil(this.destroy$)
      )
      .subscribe({
        next: (response: HttpResponse<any>) => {
          console.log(response)
      if (response === null) {
        console.log('No content');
        this.handleNoContent();
      } else {
        console.log(response)
        this.handleSuccessResponse(response);
      }
    },
    error: (error: HttpErrorResponse) => {
      console.error('HTTP Error:', error.status, error.message);
      this.handleErrorResponse(error);
    }
      });
  }

  private handleNoContent(): void {
      this.toastService.showSuccessToast('No data available');
  }

  private handleSuccessResponse(data: any): void {
    this.vulnerabilityData = data[0];
    console.log(this.vulnerabilityData)
    this.hasVulnerability = Object.keys(this.vulnerabilityData).length > 0;
    if(this.hasVulnerability) {this.toastService.showSuccessToast('Vulnerability data fetched successfully');}
    else { this.toastService.showSuccessToast('No vulnerability data found'); return;}
    this.affectedProducts = this.vulnerabilityData.affectedProducts;
    this.references = this.vulnerabilityData.references;
    console.log(this.affectedProducts);
    console.log(this.vulnerabilityData);
    this.cveId = this.vulnerabilityData.cveId;
    
    
      this.cvssMetrics = this.vulnerabilityData.cvssMetrics.sort((a: any, b: any) =>
        b.version.localeCompare(a.version)
      );
      console.log(this.cvssMetrics);
      let version = this.cvssMetrics[0].version;
      this.cvssMetrics.find((metric: any) => {
        version = metric.version >= version ? metric.version : version;
      });
      this.currentVersionData = this.cvssMetrics.find((metric: any) => metric.version === version);
      this.setMetricData(this.currentVersionData, this.btnActiveIndex);
  }

  private handleErrorResponse(error: any): void {
    console.error('Error fetching vulnerability data:', error);
    if (error.status === 0) {
      this.toastService.showErrorToast(
        'Unable to connect to the server. Please check your network or try again later.'
      );
    } else {
      this.toastService.showErrorToast(
        'Error : Failed to fetch vulnerability data'
      );
    }
   }

   setDynamicHeights() {
    const parentHeight = this.affectedProductsTemplateRef?.nativeElement.offsetHeight;
    const headerHeight = this.affectedProductsTemplateRef?.nativeElement.querySelector('.p-2')?.offsetHeight || 0;
    const desiredHeight = parentHeight - headerHeight - 10;
    this.renderer.setStyle(this.affectedProductsChildRef.nativeElement, 'height', `${desiredHeight}px`);
    const remediationParentHeight = this.remediationTemplate.nativeElement.offsetHeight;
    const remediationHeaderHeight = this.remediationTemplate.nativeElement.querySelector('.p-2')?.offsetHeight || 0;
    const remediationTableParentHeight = remediationParentHeight - remediationHeaderHeight - 10;
    this.renderer.setStyle(this.remediationChild?.nativeElement, 'height', `${remediationTableParentHeight}px`);
  }

  public setMetricData (metricData: any, index:number): void {
        document.querySelectorAll('.custom-flat-button').forEach((button, i) => {
          if (i === index) {
            this.renderer.addClass(button, 'active');
          } else {
            this.renderer.removeClass(button, 'active')
          }
        });
        this.currentVersionData = metricData;
        this.btnActiveIndex = index;
        const baseScore = this.currentVersionData?.baseScore;
        this.baseScore = baseScore;
        this.version = this.currentVersionData?.version;
        this.attackVector = this.currentVersionData.attackVector;
        this.attackComplexity = this.currentVersionData.attackComplexity;
        this.privilegesRequired = this.currentVersionData.privilegesRequired;
        this.userInteraction = this.currentVersionData.userInteraction;
        this.scope = this.currentVersionData.scope;
        this.confidentiality = this.currentVersionData.confidentiality;
        this.integrity = this.currentVersionData.integrity;
        this.availability = this.currentVersionData.availability;
        this.vectorString = this.currentVersionData.vectorString.slice(9);
        const ctx = this.severityChart?.nativeElement.getContext('2d');
        if(ctx) {
           this.drawSeverityBasedComputerChart();
        }
   }
   afterDataUpdate(){
      if (this.cdRef) {
        this.cdRef.detectChanges();
      }
      setTimeout(() => {
      this.setDynamicHeights();
      }, 50);
   }
   
   goBack(): void {
   this.location.back();
   }
}

